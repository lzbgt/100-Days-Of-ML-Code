#!/usr/bin/env python3
"""Analyze barometer logs and plot derived relative heights.

Inputs
------
- data/baro_readings.csv (generated by extract_baro.py)

Outputs (written to data/plots/)
-------------------------------
- heights_time_series.png   : rel-height vs time for each tag (self-baseline)
- median_by_file.png        : median rel-height per file (with target levels)
- cross_diff_time.png       : tagA - tagB relative height vs time (paired)
- cross_diff_by_file.png    : median per-file height difference (tagA - tagB)

Notes
-----
- Hypsometric conversion uses each tag's baseline pressure/temp from:
    * anchor medians (default) OR
    * the first file in chronological order (--baseline first)
- Expected levels are parsed from filenames like `0.5m.txt` -> 0.5 m.
"""

from __future__ import annotations

import argparse
import csv
import math
import re
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple

import matplotlib.pyplot as plt

R_DRY_AIR = 287.05  # J/(kg·K)
G0 = 9.80665  # m/s^2


def hypsometric(p_ref: float, t_ref_k: float, p: float, t_k: float) -> float:
    """Return relative height (meters) between pressure levels."""

    return (R_DRY_AIR * 0.5 * (t_ref_k + t_k) / G0) * math.log(p_ref / p)


def parse_filename_height(name: str) -> float | None:
    """Extract numeric height from filenames like `1.5m.txt` or `0.5m.txt`.

    Returns None for files without a height (e.g., anchor.txt).
    """

    m = re.search(r"(?:^|[-_])?(\d+(?:\.\d+)?)m\.txt$", name)
    return float(m.group(1)) if m else None


def load_rows(csv_path: Path) -> List[Dict[str, str]]:
    rows: List[Dict[str, str]] = []
    with csv_path.open() as f:
        reader = csv.DictReader(f)
        for r in reader:
            rows.append(r)
    if not rows:
        raise SystemExit(f"No rows found in {csv_path}")
    return rows


def build_baselines(
    rows: List[Dict[str, str]],
    mode: str,
    baseline_file: str | None = None,
) -> Dict[str, Tuple[float, float]]:
    """Return {addr: (p_ref, t_ref_K)} baselines."""

    by_addr_file: Dict[Tuple[str, str], List[Dict[str, str]]] = defaultdict(list)
    for r in rows:
        by_addr_file[(r["addr"], r["source_file"])].append(r)

    baselines: Dict[str, Tuple[float, float]] = {}
    addrs = {r["addr"] for r in rows}

    def first_sample(addr: str) -> Tuple[float, float]:
        first_row = min((r for r in rows if r["addr"] == addr), key=lambda x: x["timestamp"])
        return float(first_row["pressure_pa"]), float(first_row["temperature_c"]) + 273.15

    if mode == "anchor":
        for addr in addrs:
            anchor_rows = by_addr_file.get((addr, "anchor.txt"), [])
            if anchor_rows:
                p = median([float(r["pressure_pa"]) for r in anchor_rows])
                t = median([float(r["temperature_c"]) for r in anchor_rows]) + 273.15
                baselines[addr] = (p, t)
            else:
                # Gracefully fall back to session-first sample when anchor is absent.
                baselines[addr] = first_sample(addr)
    elif mode == "file-median" and baseline_file:
        for addr in addrs:
            rows_in_file = by_addr_file.get((addr, baseline_file), [])
            if rows_in_file:
                p = median([float(r["pressure_pa"]) for r in rows_in_file])
                t = median([float(r["temperature_c"]) for r in rows_in_file]) + 273.15
                baselines[addr] = (p, t)
            else:
                baselines[addr] = first_sample(addr)
    else:  # first file chronologically
        for addr in addrs:
            baselines[addr] = first_sample(addr)

    if not baselines:
        raise SystemExit("No baselines could be constructed. Ensure anchor.txt or data exists.")
    return baselines


def median(values: List[float]) -> float:
    values_sorted = sorted(values)
    n = len(values_sorted)
    mid = n // 2
    if n % 2:
        return values_sorted[mid]
    return 0.5 * (values_sorted[mid - 1] + values_sorted[mid])


def compute_heights(rows: List[Dict[str, str]], baselines: Dict[str, Tuple[float, float]]):
    """Add derived fields: seconds_since_start, rel_height_m."""

    t0 = datetime.fromisoformat(rows[0]["timestamp"])
    for r in rows:
        ts = datetime.fromisoformat(r["timestamp"])
        r["t_sec"] = (ts - t0).total_seconds()
        addr = r["addr"]
        if addr not in baselines:
            r["rel_height_m"] = None
            continue
        p_ref, t_ref_k = baselines[addr]
        p = float(r["pressure_pa"])
        t_k = float(r["temperature_c"]) + 273.15
        r["rel_height_m"] = hypsometric(p_ref, t_ref_k, p, t_k)


def aggregate_medians(rows: List[Dict[str, str]]):
    data = defaultdict(list)
    for r in rows:
        if r.get("rel_height_m") is None:
            continue
        key = (r["source_file"], r["addr"])
        data[key].append(r["rel_height_m"])
    med = {k: median(vs) for k, vs in data.items()}
    return med


def compute_cross_diffs(
    rows: List[Dict[str, str]],
    tag_a: str,
    tag_b: str,
    max_dt: float = 0.3,
):
    """Pair nearest-in-time samples between two tags and return (t, diff)."""

    series_a = sorted(
        [(r["t_sec"], r["rel_height_m"], r["source_file"]) for r in rows if r["addr"] == tag_a and r.get("rel_height_m") is not None],
        key=lambda x: x[0],
    )
    series_b = sorted(
        [(r["t_sec"], r["rel_height_m"], r["source_file"]) for r in rows if r["addr"] == tag_b and r.get("rel_height_m") is not None],
        key=lambda x: x[0],
    )
    diffs = []
    i = j = 0
    while i < len(series_a) and j < len(series_b):
        ta, ha, fa = series_a[i]
        tb, hb, fb = series_b[j]
        dt = abs(ta - tb)
        if dt <= max_dt:
            diffs.append((0.5 * (ta + tb), ha - hb, fa, fb))
            if ta <= tb:
                i += 1
            else:
                j += 1
        elif ta < tb:
            i += 1
        else:
            j += 1
    return diffs


def plot_time_series(rows: List[Dict[str, str]], out_dir: Path) -> None:
    out_dir.mkdir(parents=True, exist_ok=True)
    plt.figure(figsize=(10, 5))
    colors = {"BD41E": "tab:blue", "BD41F": "tab:orange"}
    for addr in sorted({r["addr"] for r in rows}):
        xs = [r["t_sec"] for r in rows if r["addr"] == addr]
        ys = [r["rel_height_m"] for r in rows if r["addr"] == addr]
        plt.plot(xs, ys, ".", ms=2, alpha=0.6, label=addr, color=colors.get(addr))
    plt.xlabel("Time (s) from first sample")
    plt.ylabel("Relative height (m)")
    plt.title("Relative height vs time")
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(out_dir / "heights_time_series.png", dpi=150)
    plt.close()


def plot_medians(medians: Dict[Tuple[str, str], float], out_dir: Path) -> None:
    """Line plot with numeric labels (clearer than bars)."""

    out_dir.mkdir(parents=True, exist_ok=True)
    files = sorted({k[0] for k in medians.keys()}, key=lambda x: (parse_filename_height(x) is None, parse_filename_height(x) or 0))
    addrs = sorted({k[1] for k in medians.keys()})
    xs = list(range(len(files)))

    plt.figure(figsize=(10, 4))
    y_all: List[float] = []
    for addr in addrs:
        ys = [medians.get((f, addr)) for f in files]
        plt.plot(xs, ys, marker="o", label=addr)
        y_all.extend([y for y in ys if y is not None])
        # annotate each point with its value
        for x_val, y_val in zip(xs, ys):
            if y_val is None:
                continue
            plt.text(x_val, y_val, f"{y_val:.3f}", ha="center", va="bottom", fontsize=8, color="black")

    targets = [parse_filename_height(f) for f in files]
    plt.plot(xs, targets, "k--", label="target m")

    plt.xticks(xs, files, rotation=30, ha="right")
    plt.ylabel("Median relative height (m)")
    plt.title("Median height per file (with values)")
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(out_dir / "median_by_file.png", dpi=150)
    plt.close()


def plot_cross_time(diffs, tag_a: str, tag_b: str, out_dir: Path) -> None:
    if not diffs:
        return
    out_dir.mkdir(parents=True, exist_ok=True)
    xs = [d[0] for d in diffs]
    ys = [d[1] for d in diffs]
    plt.figure(figsize=(10, 4))
    plt.plot(xs, ys, ".", ms=2, alpha=0.6)
    plt.axhline(0.0, color="k", lw=1, ls="--")
    plt.xlabel("Time (s) from first sample")
    plt.ylabel(f"Height diff ({tag_a}-{tag_b}) m")
    plt.title("Inter-tag relative height difference vs time")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(out_dir / "cross_diff_time.png", dpi=150)
    plt.close()


def plot_cross_by_file(medians: Dict[Tuple[str, str], float], tag_a: str, tag_b: str, out_dir: Path) -> None:
    files = []
    diffs = []
    for (fname, addr), val in sorted(medians.items(), key=lambda x: (parse_filename_height(x[0][0]) is None, parse_filename_height(x[0][0]) or 0)):
        if addr != tag_a:
            continue
        other = medians.get((fname, tag_b))
        if other is None:
            continue
        files.append(fname)
        diffs.append(val - other)
    if not diffs:
        return
    out_dir.mkdir(parents=True, exist_ok=True)
    x = range(len(files))
    plt.figure(figsize=(10, 3.8))
    plt.bar(x, diffs, width=0.6, color="tab:purple")
    plt.axhline(0.0, color="k", lw=1, ls="--")
    plt.xticks(x, files, rotation=30, ha="right")
    plt.ylabel(f"Median diff ({tag_a}-{tag_b}) m")
    plt.title("Inter-tag median height difference by file")
    plt.tight_layout()
    plt.savefig(out_dir / "cross_diff_by_file.png", dpi=150)
    plt.close()


def compute_anchor_relative(
    rows: List[Dict[str, str]],
    anchor_tag: str,
    anchor_file: str,
    moving_tag: str,
):
    """Return list of (file, t_sec, rel_height) for moving_tag relative to anchor_tag baseline.

    Baseline is median p/T of anchor_tag within anchor_file.
    """

    anchor_rows = [r for r in rows if r["addr"] == anchor_tag and r["source_file"] == anchor_file]
    if not anchor_rows:
        print(f"Anchor baseline not found: tag={anchor_tag}, file={anchor_file}")
        return None, None
    p_ref = median([float(r["pressure_pa"]) for r in anchor_rows])
    t_ref_k = median([float(r["temperature_c"]) for r in anchor_rows]) + 273.15

    rel_rows = []
    for r in rows:
        if r["addr"] != moving_tag:
            continue
        p = float(r["pressure_pa"])
        t_k = float(r["temperature_c"]) + 273.15
        rel_h = hypsometric(p_ref, t_ref_k, p, t_k)
        rel_rows.append((r["source_file"], r.get("t_sec", 0.0), rel_h))

    if not rel_rows:
        print(f"No moving-tag rows found for {moving_tag}")
        return None, None
    return (p_ref, t_ref_k), rel_rows


def plot_anchor_by_file(rel_rows, out_dir: Path) -> None:
    """Median relative height per file for anchor-based eval."""

    if not rel_rows:
        return
    out_dir.mkdir(parents=True, exist_ok=True)
    # Compute medians per file
    med = {}
    from collections import defaultdict

    bucket = defaultdict(list)
    for fname, _t, h in rel_rows:
        bucket[fname].append(h)
    files = sorted(bucket.keys(), key=lambda x: (parse_filename_height(x) is None, parse_filename_height(x) or 0))
    xs = list(range(len(files)))
    ys = []
    for f in files:
        ys.append(median(bucket[f]))

    plt.figure(figsize=(10, 4))
    plt.plot(xs, ys, marker="o", label="moving tag vs anchor")
    for x_val, y_val in zip(xs, ys):
        plt.text(x_val, y_val, f"{y_val:.3f}", ha="center", va="bottom", fontsize=8, color="black")
    targets = [parse_filename_height(f) for f in files]
    plt.plot(xs, targets, "k--", label="target m")
    plt.xticks(xs, files, rotation=30, ha="right")
    plt.ylabel("Rel height vs anchor (m)")
    plt.title("Anchor-referenced median height per file")
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(out_dir / "anchor_by_file.png", dpi=150)
    plt.close()


def plot_anchor_time(rel_rows, out_dir: Path) -> None:
    """Time series of moving tag relative to anchor baseline."""

    if not rel_rows:
        return
    out_dir.mkdir(parents=True, exist_ok=True)
    rel_rows = sorted(rel_rows, key=lambda x: x[1])
    xs = [r[1] for r in rel_rows]
    ys = [r[2] for r in rel_rows]
    plt.figure(figsize=(10, 4))
    plt.plot(xs, ys, '.', ms=2, alpha=0.6)
    plt.xlabel("Time (s) from first sample")
    plt.ylabel("Height vs anchor (m)")
    plt.title("Moving tag height relative to anchor baseline")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(out_dir / "anchor_time_series.png", dpi=150)
    plt.close()


def _fit_kb(raw: List[float], target: List[float]) -> tuple[float, float]:
    """Least-squares fit k,b so that k*raw + b ≈ target."""

    import math

    mean_raw = sum(raw) / len(raw)
    mean_t = sum(target) / len(target)
    num = sum((r - mean_raw) * (t - mean_t) for r, t in zip(raw, target))
    den = sum((r - mean_raw) ** 2 for r in raw)
    k = num / den if den else float("nan")
    b = mean_t - k * mean_raw
    rmse = math.sqrt(sum((k * r + b - t) ** 2 for r, t in zip(raw, target)) / len(raw))
    return k, b, rmse


def plot_calibrated_compare(
    files: List[str],
    self_med: Dict[str, List[float]],
    anchor_med: List[float] | None,
    k_self: float,
    b_self: float,
    k_anchor: float,
    b_anchor: float,
    out_dir: Path,
) -> None:
    """Plot raw vs calibrated curves for quick visual sanity."""

    out_dir.mkdir(parents=True, exist_ok=True)
    tag = next(iter(self_med.keys()))
    xs = list(range(len(files)))
    target = [parse_filename_height(f) for f in files]
    self_raw = self_med[tag]
    self_cal = [k_self * h + b_self for h in self_raw]
    plt.figure(figsize=(10, 5))
    plt.plot(xs, self_raw, marker="o", linestyle="-", color="tab:blue", label=f"Self raw ({tag})")
    plt.plot(xs, self_cal, marker="^", linestyle="--", color="tab:cyan", label="Self calibrated")
    if anchor_med:
        anc_raw = anchor_med
        anc_cal = [k_anchor * h + b_anchor for h in anc_raw]
        plt.plot(xs, anc_raw, marker="s", linestyle="-", color="tab:orange", label="Anchor raw")
        plt.plot(xs, anc_cal, marker="d", linestyle="--", color="tab:red", label="Anchor calibrated")
    plt.plot(xs, target, "k--", label="Target m")
    plt.xticks(xs, files, rotation=30, ha="right")
    plt.ylabel("Height (m)")
    plt.title("Raw vs calibrated (self & anchor)")
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(out_dir / "calibrated_compare.png", dpi=150)
    plt.close()


def fit_scale(medians: Dict[Tuple[str, str], float]) -> None:
    targets = {}
    for (fname, addr), val in medians.items():
        tgt = parse_filename_height(fname)
        if tgt is not None:
            targets.setdefault(addr, []).append((tgt, val))
    for addr, pairs in targets.items():
        xs, ys = zip(*sorted(pairs))
        num = sum(x * y for x, y in zip(xs, ys))
        den = sum(x * x for x in xs)
        slope = num / den if den else float("nan")
        rmse = math.sqrt(sum((y - slope * x) ** 2 for x, y in zip(xs, ys)) / len(xs))
        print(f"{addr}: scale {slope:.3f} m/m, RMSE {rmse:.3f} m")


def main() -> None:
    parser = argparse.ArgumentParser(description="Analyze barometer-derived heights and plot results")
    parser.add_argument(
        "--csv",
        type=Path,
        default=Path(__file__).resolve().parent / "data" / "baro_readings.csv",
        help="Path to baro_readings.csv (default: data/baro_readings.csv)",
    )
    parser.add_argument(
        "--baseline",
        choices=["anchor", "first", "file-median"],
        default="anchor",
        help="Baselining mode: anchor medians; first-sample per tag; or median of --baseline-file",
    )
    parser.add_argument(
        "--baseline-file",
        type=str,
        default=None,
        help="When --baseline file-median is used, take medians from this file (e.g., 0m.txt)",
    )
    parser.add_argument(
        "--pair",
        type=str,
        default=None,
        help="Tag pair for cross plots, e.g. BD41E,BD41F (default: first two tags)",
    )
    parser.add_argument(
        "--anchor-tag",
        type=str,
        default=None,
        help="Treat this tag as fixed anchor baseline (median p/T from --anchor-file)",
    )
    parser.add_argument(
        "--anchor-file",
        type=str,
        default="0m.txt",
        help="File containing anchor at reference height (default: 0m.txt)",
    )
    parser.add_argument(
        "--moving-tag",
        type=str,
        default=None,
        help="Moving tag to evaluate against anchor baseline (default: first tag not equal to anchor)",
    )
    parser.add_argument(
        "--max-dt",
        type=float,
        default=0.3,
        help="Max seconds between tag samples to pair for cross diff (default 0.3s)",
    )
    parser.add_argument(
        "--cal-scale",
        type=float,
        default=1.26,
        help="Scale factor for calibrated_compare plot (default 1.26)",
    )
    parser.add_argument(
        "--self-offset",
        type=float,
        default=0.335,
        help="Offset added before scale for self curve in calibrated_compare (default 0.335 m)",
    )
    parser.add_argument(
        "--anchor-offset",
        type=float,
        default=-0.586,
        help="Offset added before scale for anchor curve in calibrated_compare (default -0.586 m)",
    )
    parser.add_argument(
        "--outdir",
        type=Path,
        default=Path(__file__).resolve().parent / "data" / "plots",
        help="Directory to write plots (png)",
    )

    args = parser.parse_args()

    rows = load_rows(args.csv)
    baselines = build_baselines(rows, args.baseline, args.baseline_file)
    compute_heights(rows, baselines)
    medians = aggregate_medians(rows)

    # Print quick scale fit to console.
    fit_scale(medians)

    plot_time_series(rows, args.outdir)
    plot_medians(medians, args.outdir)

    # Cross-tag comparisons (self-relative alignment but inter-tag consistency).
    addrs = sorted({r["addr"] for r in rows})
    if args.pair:
        try:
            tag_a, tag_b = [x.strip() for x in args.pair.split(",")]
        except Exception as exc:  # noqa: BLE001
            raise SystemExit(f"Invalid --pair format: {args.pair}") from exc
    elif len(addrs) >= 2:
        tag_a, tag_b = addrs[0], addrs[1]
    else:
        tag_a = tag_b = None

    if tag_a and tag_b:
        diffs = compute_cross_diffs(rows, tag_a, tag_b, max_dt=args.max_dt)
        plot_cross_time(diffs, tag_a, tag_b, args.outdir)
        plot_cross_by_file(medians, tag_a, tag_b, args.outdir)
        print(f"Cross-diff plotted for {tag_a} - {tag_b} (pairs={len(diffs)})")
    else:
        print("Cross-diff plots skipped (need at least two tags or --pair).")

    # Anchor vs moving tag analysis (true-anchor scenario)
    if args.anchor_tag:
        moving_tag = args.moving_tag
        if not moving_tag:
            moving_tag = next((a for a in addrs if a != args.anchor_tag), None)
        baseline_info, rel_rows = compute_anchor_relative(rows, args.anchor_tag, args.anchor_file, moving_tag)
        if rel_rows:
            plot_anchor_by_file(rel_rows, args.outdir)
            plot_anchor_time(rel_rows, args.outdir)
            # Print medians for quick reference
            from collections import defaultdict

            bucket = defaultdict(list)
            for fname, _t, h in rel_rows:
                bucket[fname].append(h)
            files = sorted(bucket.keys(), key=lambda x: (parse_filename_height(x) is None, parse_filename_height(x) or 0))
            print(f"Anchor baseline tag={args.anchor_tag} file={args.anchor_file} baseline_p={baseline_info[0]:.1f} Pa")
            for f in files:
                vals = sorted(bucket[f])
                lo, hi = vals[0], vals[-1]
                mid = median(vals)
                print(f"  {f}: median={mid:+.3f} range=[{lo:+.3f},{hi:+.3f}] span={hi-lo:.3f}")
        else:
            print("Anchor analysis skipped (insufficient anchor or moving data).")

    print(f"Wrote plots to {args.outdir}")


if __name__ == "__main__":
    main()
